"Texture2D tx0 : register(t0);\n"
"Texture2D tx1 : register(t1);\n"
"Texture2D tx2 : register(t2);\n"
"//SamplerState samLinear : register(s0);\n"
"\n"
"\n"
"SamplerState tex0 : register(s0);\n"
"SamplerState tex1 : register(s1);\n"
"SamplerState tex2 : register(s2);\n"
"\n"
"//matrix colormatrix : register(c0);\n"
"\n"
"cbuffer ConstantBuffer : register(b0)\n"
"{\n"
"	matrix World;\n"
"	matrix View;\n"
"	matrix Projection;\n"
"	float4 paintColor;\n"
"};\n"
"\n"
"cbuffer ConstantBuffer1: register(b1)\n"
"{\n"
"	matrix colormatrix;\n"
"};\n"
"\n"
"cbuffer ConstantBuffer2: register(b2)\n"
"{\n"
"	float4 overlapEdge;\n"
"	float4 texEdgeCoord;\n"
"};\n"
"\n"
"struct VS_INPUT\n"
"{\n"
"	float4 Pos : POSITION;\n"
"	float2 Tex : TEXCOORD0;\n"
"};\n"
"\n"
"struct PS_INPUT\n"
"{\n"
"	float4 Pos : SV_POSITION;\n"
"	float2 Tex : TEXCOORD0;\n"
"};\n"
"\n"
"PS_INPUT VS(VS_INPUT input)\n"
"{\n"
"	PS_INPUT output = (PS_INPUT)0;\n"
"	output.Pos = mul(input.Pos, World);\n"
"	output.Pos = mul(output.Pos, View);\n"
"	output.Pos = mul(output.Pos, Projection);\n"
"	output.Tex = input.Tex;\n"
"	return output;\n"
"}\n"
"\n"
"PS_INPUT SCRVS(VS_INPUT Pos)\n"
"{\n"
"    return Pos;\n"
"}\n"
"\n"
"//--------------------------------------------------------------------------------------\n"
"// Pixel Shader\n"
"//--------------------------------------------------------------------------------------\n"
"float4 PS(PS_INPUT input) : SV_Target\n"
"{\n"
"	return paintColor;\n"
"}\n"
"\n"
"float4 SCRPS(PS_INPUT input) : SV_Target\n"
"{\n"
"	return tx0.Sample(tex0, input.Tex);    // Yellow, with Alpha = 1\n"
"}\n"
"\n"
"\n"
"float4 PS1(PS_INPUT input) : SV_Target\n"
"{\n"
"	float4 y = tx0.Sample(tex0, input.Tex);\n"
"	float4 u = tx1.Sample(tex1, input.Tex);\n"
"	float4 v = tx2.Sample(tex2, input.Tex);\n"
"	float xx = y.x;\n"
"	float yy = u.x;\n"
"	float zz = v.x;\n"
"	\n"
"	if (input.Tex.x < overlapEdge.x){\n"
"		xx = xx * ((input.Tex.x - texEdgeCoord.x) / (overlapEdge.x - texEdgeCoord.x));\n"
"		//yy = yy * ((input.Tex.x - texEdgeCoord.x) / (overlapEdge.x - texEdgeCoord.x));\n"
"		//zz = zz * ((input.Tex.x - texEdgeCoord.x) / (overlapEdge.x - texEdgeCoord.x));\n"
"	}\n"
"	\n"
"	if (input.Tex.x > overlapEdge.y){\n"
"		xx = xx * (texEdgeCoord.y - input.Tex.x) / (texEdgeCoord.y - overlapEdge.y);\n"
"		//yy = yy * (texEdgeCoord.y - input.Tex.x) / (texEdgeCoord.y - overlapEdge.y);\n"
"		//zz = zz * (texEdgeCoord.y - input.Tex.x) / (texEdgeCoord.y - overlapEdge.y);\n"
"	}\n"
"	\n"
"	if (input.Tex.y < overlapEdge.w){\n"
"		xx = xx * (input.Tex.y - texEdgeCoord.w) / (overlapEdge.w - texEdgeCoord.w);\n"
"		//yy = yy * (input.Tex.y - texEdgeCoord.w) / (overlapEdge.w - texEdgeCoord.w);\n"
"		//zz = zz * (input.Tex.y - texEdgeCoord.w) / (overlapEdge.w - texEdgeCoord.w);\n"
"	}\n"
"	\n"
"	if (input.Tex.y > overlapEdge.z){\n"
"		xx = xx * (texEdgeCoord.z - input.Tex.y) / (texEdgeCoord.z - overlapEdge.z);\n"
"		//yy = yy * (texEdgeCoord.z - input.Tex.y) / (texEdgeCoord.z - overlapEdge.z);\n"
"		//zz = zz * (texEdgeCoord.z - input.Tex.y) / (texEdgeCoord.z - overlapEdge.z);\n"
"	}\n"
"	\n"
"	float4 c = float4(xx, yy, zz, 1.0); \n"
"	return mul(c, colormatrix);\n"
"}\n"
"\n"
